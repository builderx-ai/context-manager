import fs from 'node:fs/promises';
import path from 'node:path';
import chalk from 'chalk';
import { CONTEXT_DIR } from './project.js';
import { readManifest } from './manifest.js';

type Target = 'claude' | 'agents' | 'codex' | 'copilot' | 'opencode' | 'kilo' | 'all';

export async function generateAll(projectDir: string, opts: { target?: string }): Promise<void> {
  // Read agent preference from manifest if not explicitly provided
  let target: Target;
  if (opts.target) {
    target = opts.target as Target;
  } else {
    const manifest = await readManifest(projectDir);
    target = (manifest.agent || 'agents') as Target;
  }

  // Support legacy 'codex' as alias for 'agents'
  if (target === 'codex') {
    target = 'agents';
  }

  const packagesRoot = path.join(projectDir, CONTEXT_DIR, 'packages');

  const indexFiles = await findFiles(packagesRoot, (p) => p.endsWith('index.md'));
  const toolClaude = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'claude.md')));
  const toolCopilot = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'copilot.md')));
  const toolOpencode = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'opencode.md')));
  const toolKilo = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'kilo.md')));

  const quickReferenceParts: string[] = [];
  for (const f of indexFiles) {
    const rel = path.relative(projectDir, f);
    const content = await fs.readFile(f, 'utf8');
    quickReferenceParts.push(`<!-- BEGIN ${rel} -->\n${content.trim()}\n<!-- END ${rel} -->\n`);
  }

  const claudeExtra: string[] = [];
  for (const f of toolClaude) claudeExtra.push(await fs.readFile(f, 'utf8'));
  const copilotExtra: string[] = [];
  for (const f of toolCopilot) copilotExtra.push(await fs.readFile(f, 'utf8'));
  const opencodeExtra: string[] = [];
  for (const f of toolOpencode) opencodeExtra.push(await fs.readFile(f, 'utf8'));
  const kiloExtra: string[] = [];
  for (const f of toolKilo) kiloExtra.push(await fs.readFile(f, 'utf8'));

  if (target === 'all' || target === 'claude') {
    const out = buildClaudeMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, claudeExtra.join('\n'));
    await fs.writeFile(path.join(projectDir, 'CLAUDE.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated CLAUDE.md'));
  }

  if (target === 'all' || target === 'agents') {
    const out = buildAgentsMd(projectDir, quickReferenceParts.join('\n'), packagesRoot);
    await fs.writeFile(path.join(projectDir, 'AGENTS.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated AGENTS.md'));
  }

  if (target === 'all' || target === 'copilot') {
    const ghDir = path.join(projectDir, '.github');
    await fs.mkdir(ghDir, { recursive: true });
    const out = buildCopilotMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, copilotExtra.join('\n'));
    await fs.writeFile(path.join(ghDir, 'copilot-instructions.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated .github/copilot-instructions.md'));
  }

  if (target === 'all' || target === 'opencode') {
    const out = buildOpencodeMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, opencodeExtra.join('\n'));
    await fs.writeFile(path.join(projectDir, 'opencode.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated opencode.md'));
  }

  if (target === 'all' || target === 'kilo') {
    const out = buildKiloMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, kiloExtra.join('\n'));
    await fs.writeFile(path.join(projectDir, 'kilo.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated kilo.md'));
  }
}

function buildClaudeMd(projectDir: string, quickRef: string, packagesRoot: string, claudeExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# CLAUDE.md\n\nThis file is auto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## Available Contexts\n\nRead detailed files under \`${pkgRel}/\` on demand.\n\n${claudeExtra ? `## Claude-Specific Guidance\n\n${claudeExtra}\n` : ''}`;
}

function buildAgentsMd(projectDir: string, quickRef: string, packagesRoot: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# AGENTS.md\n\nAuto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## How to use\n\nWhen you need more detail, read the relevant files in \`${pkgRel}/\`.\n`;
}

function buildCopilotMd(projectDir: string, quickRef: string, packagesRoot: string, copilotExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# Copilot instructions\n\nAuto-generated by ctx (context-manager).\n\n## Summary\n\n${quickRef || '_No contexts installed yet._'}\n\n## Detailed references\n\nSee detailed context files under \`${pkgRel}/\`.\n\n${copilotExtra ? `## Copilot-specific\n\n${copilotExtra}\n` : ''}`;
}

function buildOpencodeMd(projectDir: string, quickRef: string, packagesRoot: string, opencodeExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# OpenCode Instructions\n\nAuto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## Available Contexts\n\nRead detailed files under \`${pkgRel}/\` on demand.\n\n${opencodeExtra ? `## OpenCode-Specific Guidance\n\n${opencodeExtra}\n` : ''}`;
}

function buildKiloMd(projectDir: string, quickRef: string, packagesRoot: string, kiloExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# Kilo Code Instructions\n\nAuto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## Available Contexts\n\nRead detailed files under \`${pkgRel}/\` on demand.\n\n${kiloExtra ? `## Kilo-Specific Guidance\n\n${kiloExtra}\n` : ''}`;
}

async function findFiles(root: string, predicate: (p: string) => boolean): Promise<string[]> {
  const out: string[] = [];
  async function walk(dir: string): Promise<void> {
    let entries: any[] = [];
    try {
      entries = await fs.readdir(dir, { withFileTypes: true });
    } catch {
      return;
    }
    for (const e of entries) {
      const p = path.join(dir, e.name);
      if (e.isDirectory()) await walk(p);
      else if (e.isFile() && predicate(p)) out.push(p);
    }
  }
  await walk(root);
  return out;
}
