import fs from 'node:fs/promises';
import path from 'node:path';
import chalk from 'chalk';
import { CONTEXT_DIR } from './project.js';

type Target = 'claude' | 'codex' | 'copilot' | 'all';

export async function generateAll(projectDir: string, opts: { target: string }): Promise<void> {
  const target = (opts.target ?? 'all') as Target;
  const packagesRoot = path.join(projectDir, CONTEXT_DIR, 'packages');

  const indexFiles = await findFiles(packagesRoot, (p) => p.endsWith('index.md'));
  const toolClaude = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'claude.md')));
  const toolCopilot = await findFiles(packagesRoot, (p) => p.endsWith(path.join('tools', 'copilot.md')));

  const quickReferenceParts: string[] = [];
  for (const f of indexFiles) {
    const rel = path.relative(projectDir, f);
    const content = await fs.readFile(f, 'utf8');
    quickReferenceParts.push(`<!-- BEGIN ${rel} -->\n${content.trim()}\n<!-- END ${rel} -->\n`);
  }

  const claudeExtra: string[] = [];
  for (const f of toolClaude) claudeExtra.push(await fs.readFile(f, 'utf8'));
  const copilotExtra: string[] = [];
  for (const f of toolCopilot) copilotExtra.push(await fs.readFile(f, 'utf8'));

  if (target === 'all' || target === 'claude') {
    const out = buildClaudeMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, claudeExtra.join('\n'));
    await fs.writeFile(path.join(projectDir, 'CLAUDE.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated CLAUDE.md'));
  }

  if (target === 'all' || target === 'codex') {
    const out = buildAgentsMd(projectDir, quickReferenceParts.join('\n'), packagesRoot);
    await fs.writeFile(path.join(projectDir, 'AGENTS.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated AGENTS.md'));
  }

  if (target === 'all' || target === 'copilot') {
    const ghDir = path.join(projectDir, '.github');
    await fs.mkdir(ghDir, { recursive: true });
    const out = buildCopilotMd(projectDir, quickReferenceParts.join('\n'), packagesRoot, copilotExtra.join('\n'));
    await fs.writeFile(path.join(ghDir, 'copilot-instructions.md'), out);
    // eslint-disable-next-line no-console
    console.log(chalk.green('✓ Generated .github/copilot-instructions.md'));
  }
}

function buildClaudeMd(projectDir: string, quickRef: string, packagesRoot: string, claudeExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# CLAUDE.md\n\nThis file is auto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## Available Contexts\n\nRead detailed files under \`${pkgRel}/\` on demand.\n\n${claudeExtra ? `## Claude-Specific Guidance\n\n${claudeExtra}\n` : ''}`;
}

function buildAgentsMd(projectDir: string, quickRef: string, packagesRoot: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# AGENTS.md\n\nAuto-generated by ctx (context-manager).\n\n## Context Sources\n\nContexts are located in \`${pkgRel}/\`.\n\n## Quick Reference\n\n${quickRef || '_No contexts installed yet._'}\n\n## How to use\n\nWhen you need more detail, read the relevant files in \`${pkgRel}/\`.\n`;
}

function buildCopilotMd(projectDir: string, quickRef: string, packagesRoot: string, copilotExtra: string): string {
  const pkgRel = path.relative(projectDir, packagesRoot).replace(/\\/g, '/');
  return `# Copilot instructions\n\nAuto-generated by ctx (context-manager).\n\n## Summary\n\n${quickRef || '_No contexts installed yet._'}\n\n## Detailed references\n\nSee detailed context files under \`${pkgRel}/\`.\n\n${copilotExtra ? `## Copilot-specific\n\n${copilotExtra}\n` : ''}`;
}

async function findFiles(root: string, predicate: (p: string) => boolean): Promise<string[]> {
  const out: string[] = [];
  async function walk(dir: string): Promise<void> {
    let entries: any[] = [];
    try {
      entries = await fs.readdir(dir, { withFileTypes: true });
    } catch {
      return;
    }
    for (const e of entries) {
      const p = path.join(dir, e.name);
      if (e.isDirectory()) await walk(p);
      else if (e.isFile() && predicate(p)) out.push(p);
    }
  }
  await walk(root);
  return out;
}
